#!/usr/bin/env python3
import json
import matplotlib.pyplot as plt
import numpy as np
import argparse

def punchPlotTau(plotFileName, tau, points, pathTicks, pathLabels):
    nbands = len(tau[0,:])
    # plot the lifetimes, colored by band, for all dimensions
    plt.figure(figsize=(6,4.2))
    colors = plt.get_cmap('winter')(np.linspace(0,1,nbands))
    for ib in range(nbands):
        y = tau[:,ib]
        x = points

        indexes = np.where(y==0.)

        for index in indexes:
            try:
                y[index] = y[index-1]
            except IndexError:
                try:
                    y[index] = y[index+1]
                except IndexError:
                    raise IndexError("Not enough points in path?")
                
        plt.plot(x, y, label="band #{}".format(ib+1))

    # plot aesthetics
    plt.yscale('log')
    plt.ylabel(r'$\tau_{' + data['particleType'] + '}$ [' +
               data['relaxationTimeUnit'] + ']',fontsize=12)
    plt.xlim(points[0],points[-1])
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

    # Find limits of the y axis
    flattenedTau = tau.flatten()
    zeroIndex = np.argwhere(flattenedTau==0.)
    flattenedTau = np.delete(flattenedTau, zeroIndex)
    ymin = 10**np.floor(np.log10(np.min(flattenedTau)))
    ymax = 10**np.ceil(np.log10(np.max(flattenedTau)))
    plt.ylim(ymin, ymax)
    plt.ylim(0,10000)

    plt.tight_layout()
    plt.xticks(pathTicks,pathLabels,fontsize=12)
    for i in pathTicks:
        plt.axvline(i, color='grey')
    
    plt.savefig(plotFileName)
    plt.show(block=False)

#--------------------------------

def punchPlotBandTau(plotFileName2, energy, linewidth,
                     points, pathTicks, pathLabels, mu=None):

    magFactor = 10. if data["particleType"]=="phonon" else 1.
    
    # plot some vertical lines at high sym points
    plt.figure(figsize=(5.5,5))
    for i in pathTicks:
        plt.axvline(i, color='grey')

    if "eV" == data2['energyUnit'] and data["particleType"]=="phonon":
        energy *= 1000. # conversion eV to meV
        linewidth *= 1000.
        data2['energyUnit'] = "meV"
    
    # if fermiLevel as set in the input file,
    # we can also read it in and plot it
    if('fermiLevel' in data):
        plt.axhline(0, color='grey', ls='--')
        energyLabel = r'E-E$_F$ [' + data2['energyUnit'] +']'
    # if it wasn't set, we won't subtract
    # anything from the band energies
    else:
        mu = 0.
        energyLabel = r'Energy $\pm$ 10$\cdot$linewith [' + data2['energyUnit'] +']'
        
    # plot the bands
    numBands = len(energies[0,:])
    for i in range(numBands):
        plt.plot(points, energies[:,i] - mu, 'k-', color='royalblue')
        
        error = linewidth[:,i]
        plt.fill_between(points,
                         energies[:,i] - mu - error*magFactor,
                         energies[:,i] - mu + error*magFactor,
                         color="orange",alpha=0.5)
        # *10 is a magnification factor
        
    # plot aesthetics
    plt.xticks(pathTicks,pathLabels,fontsize=12)
    plt.yticks(fontsize=12)
    plt.ylabel(energyLabel,fontsize=14)
    # plt.ylim(None, None)
    plt.ylim(-20,20)
    plt.xlim(points[0],points[-1])

    plt.axhline(0, color='grey', ls='-')

    plt.tight_layout()
    
    plt.savefig(plotFileName2)
    plt.show(block=False)

#--------------------------------    
    
if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Plot relaxation times that "
                                     "have been generated by Phoebe")
    parser.add_argument("INPUT",
                        help="Name of the JSON file with relaxation times")
    parser.add_argument("INPUT2",
                        help="Name of the JSON file with bandstructure on path")
    args = parser.parse_args()
    
    # load in the json output
    jfileName = args.INPUT
    with open(jfileName) as jfile:
        data = json.load(jfile)

        # some relaxation times may be None (e.g. acoustic phonon modes at Gamma)
        # we replace that with 0, in order to be plotted
        try:
            data['relaxationTimes'] =[ [ [ 0. if x==None else x for x in y]
                                         for y in z ]
                                       for z in data['relaxationTimes'] ]
        except KeyError:
            raise KeyError("relaxation times not found."
                           "Are you using the correct input json file?")
            
    # unpack the json file
    tau = np.array(data['relaxationTimes'])    # dimensions (iCalc, ik, ib)
    lwidths = np.array(data['linewidths'])    # dimensions (iCalc, ik, ib)
    mu = np.array(data['chemicalPotentials'])
    T = np.array(data['temperatures'])


    # Could also load in group velocities, or wavevectors
    #vels = np.array(data['velocities'])         # dimensions: (iCalc, ik, ib, dim)
    #wavevectors = np.array(data['wavevectorCoordinates']) # dimensions: (ik, dim)
    
    # for now, let's select one calculation
    # the index used to select the calculation
    # also corresponds to the index for the temperature
    # and chemical potential of that calculation as stored
    # in those arrays.
    calcIndex = 0
    tau = tau[calcIndex]
    lwidths = lwidths[calcIndex]
    mu = mu[calcIndex]
    print("Calculation Temperature: ", T[calcIndex])



    # Load the bandstructure file with the kpoints
    jfileName2 = args.INPUT2
    with open(jfileName2) as jfile:
        data2 = json.load(jfile)
    # unpack the json file
    try:
        pathLabels = data2['highSymLabels']
    except KeyError:
        raise KeyError("highSymLabels not found. "
                       "Are you using the correct input json file?")
    pathTicks = data2['highSymIndices']
    points = np.array(data2['wavevectorIndices'])
    energies = np.array(data2['energies'])

    # if the path has a fictitious discontinuity
    # e.g. in going from X=(0.50000  0.00000 0.5000) to X=(0.50000 -0.50000 0.0000)
    # (which are the same in a FCC lattice), the JSON plots two different points
    # Here we recombine them into one. Equality is checked by the label
    enIndexToDelete = []
    tkIndexToDelete = []
    for i in range(len(pathLabels)-1):
        if ( pathLabels[i] == pathLabels[i+1] and pathTicks[i] != pathTicks[i+1]):
            tkIndexToDelete.append(i+1)
            enIndexToDelete.append(pathTicks[i+1])
    for en,tk in zip(enIndexToDelete[::-1],tkIndexToDelete[::-1]):
        points = np.delete(points, -1)
        pathLabels = np.delete(pathLabels, tk)
        pathTicks = np.delete(pathTicks, tk)
        pathTicks[tk:] -= 1
        energies = np.delete(energies, en, 0)
        tau = np.delete(tau, en, 0)
        lwidths = np.delete(lwidths, en, 0)
    
    plotFileName = "./" + jfileName.rstrip(".json")+".tau.pdf"
    punchPlotTau(plotFileName, tau, points, pathTicks, pathLabels)

    plotFileName2 = "./" + jfileName2.rstrip(".json")+".tau.pdf"
    punchPlotBandTau(plotFileName2, energies, lwidths,
                     points, pathTicks, pathLabels, mu)
